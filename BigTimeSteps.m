function BigTimeSteps(DT, dtSmall, nSteps, speed, gravity_switch, exForce, xf, krylovIter)
	%% KeyFrame force controls animation 

	% This matlab code computes keyframe force which controls the animation. 
	% Combined with matrix exponential time integration.

	% Get the connectivity list of each tetrahedral.
	CnctList = DT.ConnectivityList;

	% Get all points coordinates generated by Delaunay Triangulation method.
	V = DT.Points;

	% Get boundaryFacets for the mesh bar.
	boundaryFacets = freeBoundary(DT);

	% Call external FEM interface to get Mass and stiffness(K)
	fem = WorldFEM('elastic_linear_tetrahedra', V, CnctList);
	% Get mass for the bar
	M = mass(fem);
	% Get stiffness matrix for the bar
	K = 30*stiffness(fem);

	%% Fix Left side of the bar

	% We want the left side of the bat to be fixed. 
	% since X goes from -2 to 2, simply find the minimum elements in V
	leftV = (V(:, 1) == min(V(:, 1)));
	% Create a matrix eleminates leftV points.
	P = diag(abs(leftV - 1));
	% Delete rows which are all zeros.
	P(sum(P, 1) ==0, :) = [];
    P = kron(P, eye(3));
    % q is a stacked vector, the first half holds displacements and second
	% half contains velocity.
	q0 = zeros(6*size(V, 1), 1);
    Pbig = [P, zeros(size(P)); zeros(size(P)), P];
    

	%% Ignore Left side effects.

	% Since the left side of the bar is fixed, we don't need to calculate
	% Those noeds in order to reduce computation. To do this we can use 
	% matrix multiplication with P.
	Mp = (P*M*P');
	Kp = (P*K*P');

	%% Implicit Time integration Equation

	% By deriving force and displacement equations of this system, we 
	% can get two matrix of implicit time integration equation.
	% A*q@n = B*q@n-1.
	numDOFs = size(P,1);
	A = [eye(numDOFs, numDOFs), -(eye(numDOFs, numDOFs)*dtSmall); zeros(numDOFs,numDOFs), (Mp-dtSmall^2*Kp)];
	B = [eye(numDOFs, numDOFs), zeros(numDOFs, numDOFs); dtSmall*Kp, Mp];
	C = A\B;
    % Calculate eigenVector and eigenValue of C.
    [eigV, eigD] = eig(C);
	

	%% External effects to the bar

	% This section we can add different external effects to the bar, 
	% like velocity, gravity and external force. 
    
	% Set initial speed.
	q0 = barSpeed(q0, speed);

	% Set gravity.
	if(gravity_switch == true)
		gForce = gravity(q0, M);
        gForceP = (Pbig*gForce);
        Gdisplacement = A\gForceP;
    else
        Gdisplacement = zeros(size(Pbig, 1), 1);
    end
    % Eleminate left side nodes. 
	q0p = (Pbig*q0);

	%% Matrix exponential time 

	% Matrix exponential can be written as eigenvalue exponential.
	% We can use this property to derive the animation of the bar.
    
    %[rGQ, eigGV, eigGD] = eigReduced(inv(A), Gdisplacement, 100);
	identityC = eye(2*numDOFs, 2*numDOFs);
    %identityReducedC = eye(krylovIter, krylovIter);
	cExp = eigV*(eigD^nSteps)/eigV;
    geoSum = (identityC-(C))\(identityC-cExp);
    %cExp = rQ*cExp*rQ';
    %geoSum = rGQ*geoSum*rGQ';
    disG = geoSum*(Gdisplacement);
    linearSum = (C-identityC)\(geoSum-(nSteps+1)*identityC);
    linearForce = calculateExternalForce(V, P, q0, q0p, Pbig, disG, cExp, linearSum, xf);
    
    [rQ, eigV, eigD] = eigReduced(C, q0p, krylovIter);
	frame = 0;
    total_time = 0;
	for c = 1:1:nSteps
        % Count the time interval for each iteration. 
		tic;
		% Exponential matrix of C can be written as:
		cExp = eigV*(eigD^c)/eigV;
        cExp = rQ*cExp*rQ';
		% Gravity geometric matrix sum can be written as:
		if(gravity_switch == true)
            
			geoSum = (identityC-C)\(identityC-cExp);
            
            %geoSum = geoSum*(eigGV*(eigGD)/eigGV);
            %geoSum = rGQ*(geoSum)*rGQ';
			disG = geoSum*(Gdisplacement);
			final = cExp*q0p - disG;
		else
			% Final stack vector:
			final = cExp*q0p;
        end
        %linearSum = (C-identityC)\(geoSum-(c+1)*identityC);
        %extForceDis = linearSum*linearForce;
        %final = final + extForceDis;
		% Revert back all nodes
		final  = final'*Pbig;
		% Displacement 
		displacement = reshape(final(1:end/2), size(V, 2), size(V, 1))';
        x = real(displacement)+V;

        %% Draw animation 
        drawnow;
        t = trimesh(boundaryFacets, x(:,1), x(:,2),x(:,3));
        t.EdgeColor = [0,0,0];
        t.FaceColor = [144 216 196]/255;
        grid off
    
        %axis vis3d
        axis equal;
        %axis vis3d;
        axis([-3 7 -4.6 4.5 -3 3])
        xlabel('x');
        ylabel('y');
        zlabel('z');
        view(2);
        lighting none;
        toc;
        t = toc;
        %elapsed_time(c) = t;
        total_time = total_time+t;
        time_avg = total_time/nSteps;
        
        % Record the animation. 
        frame = frame + 1;
        frameF(frame) = getframe;
        fprintf('Itertation: %d \n', frame);
        % line(
    end
    %time_avg = mean(elapsed_time)
	video = VideoWriter('Gravity.avi', 'Uncompressed AVI');
     video.FrameRate = 10;
     open(video)
     writeVideo(video, frameF);
    fprintf('Average Elapsed time is %f seconds. \n', time_avg);
end








